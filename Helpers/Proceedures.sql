
--SQL PROCEDURE

--CHAIN OF SQL COMMANDS AND CODES THAT EXECUTES ONE AFTER ANOTHER 
--(CALL REFRESH_EXCH_RATES_SQL() )


-- A proceedure can also be called by task. That means we can create a task that would call this proceedure daily creating multiple tables. 
CREATE OR REPLACE PROCEDURE REFRESH_EXCH_RATES_SQL()
RETURNS VARCHAR(16777216)
LANGUAGE SQL
EXECUTE AS OWNER
AS '

begin
----------LOOKUP_USD_EUR_EXCHANGE_RATES----------
CREATE OR REPLACE TRANSIENT TABLE DIMENSION.USD_EUR_RATES AS
WITH EXCH_RATES AS(
  SELECT 
  "Currency Unit" as CURRENCY,
  "Value" as FROM_USD,
  (1/FROM_USD) as TO_USD,
  -- The start date is the day after the previous close
  NVL(LAG(DATEADD(DAY, 1, "Date"), 1) OVER (PARTITION BY CURRENCY ORDER BY "Date" ASC), ''1900-01-01''::DATE) AS START_DATE,
  CASE -- when it is the last row, make the end date tomorrow to ensure we can''''t lose same-day records
  WHEN LAG(DATEADD(DAY, 1, "Date"), -1) OVER (PARTITION BY CURRENCY ORDER BY "Date" ASC) IS NULL THEN SYSDATE()::DATE + 1
  ELSE "Date" 
  END AS END_DATE
  FROM "KNOEMA_ECONOMY_DATA_ATLAS"."ECONOMY"."EXRATESCC2018"
  WHERE
  ("Currency Unit" IN (''EUR'', ''MAD'', ''CNY'', ''GBP'', ''JPY'', ''PLN'', ''MKD'', ''CZK'', ''MDL'', ''RON'', ''RUB'')
   OR "Currency Unit" IN (SELECT EN_CURR FROM VIEWS.MSTR_V))
  AND "Indicator Name" = ''Close''
  AND "Frequency" = ''D''
UNION ALL -- JUST IN CASE THE LOCAL CURRENCY IS USD
  SELECT ''USD'', 1, 1, ''1900-01-01''::DATE, SYSDATE()::DATE + 1
)
SELECT
D.DAY_DT, 
LOCAL_RATES.CURRENCY,
LOCAL_RATES.TO_USD, 
LOCAL_RATES.TO_USD * EUR_RATES.FROM_USD AS TO_EUR,
LOCAL_RATES.FROM_USD, 
LOCAL_RATES.FROM_USD * EUR_RATES.TO_USD AS FROM_EUR,
SYSDATE() AS ETL_LAST_REFRESH_TS
FROM
DIMENSION.CALENDAR_DAYS D
JOIN EXCH_RATES LOCAL_RATES ON D.DAY_DT BETWEEN LOCAL_RATES.START_DATE AND LOCAL_RATES.END_DATE
JOIN EXCH_RATES EUR_RATES ON D.DAY_DT BETWEEN EUR_RATES.START_DATE AND EUR_RATES.END_DATE AND EUR_RATES.CURRENCY = ''EUR''
ORDER BY 1, 2;    

----------LOOKUP_CURRENT_USD_EUR_EXCHANGE_RATES----------
CREATE OR REPLACE TRANSIENT TABLE DIMENSION.CURRENT_USD_EUR_RATES AS
SELECT 
CURRENCY,
TO_USD, 
TO_EUR,
FROM_USD, 
FROM_EUR,
ETL_LAST_REFRESH_TS
FROM DIMENSION.USD_EUR_RATES EXCH
WHERE EXCH.DAY_DT = (SELECT MAX(LATEST.DAY_DT) FROM DIMENSION.USD_EUR_RATES LATEST)
ORDER BY 1;

----------LOOKUP_ALL_EXCHANGE_RATES----------
CREATE OR REPLACE TRANSIENT TABLE DIMENSION.ALL_RATES AS
WITH EXCH_RATES AS(
  SELECT 
  "Currency Unit" as CURRENCY,
  "Value" as FROM_USD,
  (1/FROM_USD) as TO_USD,
  -- The start date is the day after the previous close
  NVL(LAG(DATEADD(DAY, 1, "Date"), 1) OVER (PARTITION BY CURRENCY ORDER BY "Date" ASC), ''1900-01-01''::DATE) AS START_DATE,
  CASE -- when it is the last row, make the end date tomorrow to ensure we can''''t lose same-day records
  WHEN LAG(DATEADD(DAY, 1, "Date"), -1) OVER (PARTITION BY CURRENCY ORDER BY "Date" ASC) IS NULL THEN SYSDATE()::DATE + 1
  ELSE "Date" 
  END AS END_DATE
  FROM "KNOEMA_ECONOMY_DATA_ATLAS"."ECONOMY"."EXRATESCC2018"
  WHERE
  ("Currency Unit" IN (''EUR'', ''MAD'', ''CNY'', ''GBP'', ''JPY'', ''PLN'', ''MKD'', ''CZK'', ''MDL'', ''RON'', ''RUB'')
   OR "Currency Unit" IN (SELECT EN_CURR FROM VIEWS.MSTR_V))
  AND "Indicator Name" = ''Close''
  AND "Frequency" = ''D''
UNION ALL -- JUST IN CASE THE LOCAL CURRENCY IS USD
  SELECT ''USD'', 1, 1, ''1900-01-01''::DATE, SYSDATE()::DATE + 1
)
select d.day_dt,
    FIRST_RATE.CURRENCY FROM_currency,
    SECOND_RATE.CURRENCY TO_CURRENCY,
    FIRST_RATE.to_usd * SECOND_RATE.from_usd as CONVERSION_RATE,
    FIRST_RATE.FROM_usd * SECOND_RATE.to_usd as INVERSE_CONVERSION_RATE,
    SYSDATE() AS ETL_LAST_REFRESH_TS
from DIMENSION.DIM_DAYS d
    join exch_rates FIRST_RATE on d.day_dt between FIRST_RATE.start_date and FIRST_RATE.end_date
    join exch_rates SECOND_RATE on d.day_dt between SECOND_RATE.start_date and SECOND_RATE.end_date
order by 1, 2, 3;

----------LOOKUP_CURRENT_ALL_EXCHANGE_RATES----------
CREATE OR REPLACE TRANSIENT TABLE DIMENSION.CURRENT_ALL_RATES AS
SELECT FROM_currency,
    TO_CURRENCY,
    CONVERSION_RATE,
    INVERSE_CONVERSION_RATE,
    ETL_LAST_REFRESH_TS
FROM DIMENSION.ALL_RATES EXCH
WHERE EXCH.DAY_DT = (
        SELECT MAX(LATEST.DAY_DT)
        FROM DIMENSION.ALL_RATES LATEST
    )
ORDER BY 1, 2;

	RETURN ''SUCCESS''; 
	
end;
';
